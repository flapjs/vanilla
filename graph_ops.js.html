<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graph_ops.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graph_ops.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module graph_ops */

import * as hist from './history.js';
import * as drawing from './drawing.js';
import * as consts from './consts.js';
import * as compute from './compute.js';
import * as linalg from './linalg.js';
import { Queue, deep_equal } from './util.js';
import * as menus from './menus.js';  // I know this is a circular dep, but it makes more sense this way
import * as graph_components from './graph_components.js';

/**
 * go through the list of used names for a vertex and find the smallest unused
 * @param {Object} graph - the graph in which we are looking for an unused name
 * @returns the smallest unused name for a vertex
 */
export function find_unused_name(graph) {
  const prefix = 'q';  // using standard notation
  let i;
  for (i = 0; i &lt;= Object.keys(graph).length; i++) {  // we don't need to look further than how many elements in the set
    if (!(prefix+`${i}` in graph)) {
      break;
    }
  }
  return prefix+`${i}`;
}

/**
 * create a vertex at the place the user has clicked
 * @param {Object} graph - the graph in which we are creating a new vertex
 * @param {float} x - x position of the user mouse click wrt canvas
 * @param {float} y - y position of the user mouse click wrt canvas
 * @param {float} radius - the radius of the graphical element
 */
export function create_vertex(graph, x, y, radius) {
  const name = find_unused_name(graph);
  const vertex = graph_components.make_vertex(name, x, y, radius, !Object.keys(graph).length);
  graph[name] = vertex;
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * deletes a vertex by its name as well as its associated edges
 * @param {Object} graph - the graph containing the vertex v
 * @param {string} v - the vertex you want to delete
 */
export function delete_vertex(graph, v) {
  menus.remove_context_menu();
  if (graph[v].is_start) {  // we will need a start replacement
    for (const u of Object.keys(graph)) {
      if (u === v) {
        continue;
      }
      set_start(graph, u);
      break;
    }
  }
  delete graph[v];  // remove this vertex
  for (const vertex of Object.values(graph)) {
    vertex.out = vertex.out.filter(edge => edge.to !== v);
  }
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * renames the vertex with the new name, if name exists, nothing will be changed and user will be prompted
 * @param {Object} graph - the graph containing the vertex v
 * @param {string} v - the vertex to rename
 * @param {*} new_name - new name of the vertex
 */
export function rename_vertex(graph, v, new_name) {
  menus.remove_context_menu();
  if (v === new_name) {  // nothing to do
    return;
  } else if (new_name in graph) {
    alert(new_name + ' already exists');
  } else {
    graph[new_name] = graph[v];  // duplicate
    delete graph[v];  // remove old
    for (const vertex of Object.values(graph)) {
      for (const edge of vertex.out) {
        if (edge.from === v) {
          edge.from = new_name;
        }
        if (edge.to === v) {
          edge.to = new_name;
        }
      }
    }
  }
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * mark a vertex as start
 * @param {Object} graph - the graph containing the vertex v
 * @param {string} v - name of the vertex
 */
export function set_start(graph, v) {
  for (const vertex of Object.values(graph)) {
    vertex.is_start = false;
  }
  graph[v].is_start = true;
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * toggle whether a vertex is accept
 * @param {Object} graph - the graph containing the vertex v
 * @param {string} v - name of the vertex
 */
export function toggle_final(graph, v) {
  const vertex = graph[v];
  vertex.is_final = !vertex.is_final;
  if (vertex.is_final) {  // adding a circle
    drawing.draw_final_circle(vertex);
  } else {  // removing the circle, requires drawing
    drawing.draw(graph);
  }
  hist.push_history(graph);
}

/**
 * creates an edge between two vertices and draw it on the screen
 * @param {Object} graph - the graph in which we are creating a new edge
 * @param {string} u - from vertex
 * @param {string} v - to vertex
 * @param {float} angle1 - the angle which the cursor left the from vertex
 * @param {float} angle2 - the angle which the cursor entered the to vertex
 * @param {string} pop_symbol - the symbol to pop on top of the stack
 * @param {string} push_symbol - the symbol to push on top of the stack
 */
export function create_edge(graph, u, v, angle1, angle2) {
  const vertex = graph[u];
  // now we add the edge to the graph and draw it
  let a1 = 0.5, a2 = 0;
  if (u === v) {  // self loop
    a1 = 0.5, a2 = 1; 
  }
  // make empty edge to be modified by user
  const edge = graph_components.make_edge(u, v, consts.EMPTY_SYMBOL, a1, a2, angle1, angle2);
  vertex.out.push(edge);
  drawing.draw(graph);
  hist.push_history(graph);
  const [, , mid] = drawing.compute_edge_geometry(graph, edge);
  // context menu to modify the edge right after
  menus.display_edge_menu(graph, edge, ...drawing.canvas_px_to_window_px(mid));
}

/**
 * delete an edge of the graph and draw
 * @param {Object} graph - the graph containing the edge we want to delete
 * @param {Object} edge the edge we want to get rid of
 */
export function delete_edge(graph, edge) {
  menus.remove_context_menu();
  for (const vertex of Object.values(graph)) {
    vertex.out = vertex.out.filter(e => !deep_equal(e, edge));
  }
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * rename the transition of an edge
 * @param {Object} graph - the graph containing the edge we want to rename
 * @param {Object} edge the edge object of which we want to rename the transition
 * @param {string} new_transition - new transition symbol
 * @param {string} new_pop - new pop symbol
 * @param {string} new_push - new push symbol
 * @param {string} new_left_right - new move (left or right)
 */
export function rename_edge(graph, edge, new_transition, new_pop, new_push, new_left_right) {
  menus.remove_context_menu();
  if (new_transition === edge.transition &amp;&amp;
      new_push === edge.push_symbol &amp;&amp;
      new_pop === edge.pop_symbol &amp;&amp;
      new_left_right === edge.move) {
    return;  // nothing changed, so nothing to do
  }
  [edge.transition, edge.push_symbol, edge.pop_symbol, edge.move] = [new_transition, new_push, new_pop, new_left_right];
  drawing.draw(graph);
  hist.push_history(graph);
}

/**
 * 
 * @param {Array&lt;string>} states - a list of state labels that are to be combined
 * @returns {string} [q3, q0, q5] -> '{q0,q3,q5}'
 */
function combine_state_labels(states) {
  // convert to array and sort
  states = [...states].sort((u, v) => {
    // u, v of the form qn, qm where n, m integers
    if (u.substr(0, 1) === v.substr(0, 1) &amp;&amp; !isNaN(u.substr(1)) &amp;&amp; !isNaN(v.substr(1))) {
      return parseInt(u.substr(1)) - parseInt(v.substr(1));  // return the numeric comparison
    } else {
      return u &lt; v;  // use the string comparisn
    }
  });
  return '{'+ states.join(',') +'}';
}

export function NFA_to_DFA(NFA) {
  //TODO if (is already an DFA) return;
  // initialize graph and make trap state
  const alphabet = compute.compute_alphabet(NFA); // these will be all transitions symbols
  let vertex_position = [200, 200];  // initial position of a new state
  const DFA = {};  // new graph to populate
  DFA[consts.TRAP_STATE] = graph_components.make_vertex(
    consts.TRAP_STATE, ...vertex_position, consts.DEFAULT_VERTEX_RADIUS);  // add a trap state
  vertex_position = linalg.add(3*consts.DEFAULT_VERTEX_RADIUS, vertex_position);  // increment vertex position
  let trap_state_used = false;  // assume we haven't used the trap state yet
  for (const letter of alphabet) {
    DFA[consts.TRAP_STATE].out.push(graph_components.make_edge(consts.TRAP_STATE, consts.TRAP_STATE, letter));
  }

  // make start state
  let NFA_states = compute.closure(NFA, new Set([compute.find_start(NFA)]));  // find the start states
  let DFA_state = combine_state_labels(NFA_states);  // merge them
  DFA[DFA_state] = graph_components.make_vertex(
    DFA_state, ...vertex_position, consts.DEFAULT_VERTEX_RADIUS, true, compute.contains_final(NFA, NFA_states));
  vertex_position = linalg.add(3*consts.DEFAULT_VERTEX_RADIUS, vertex_position);  // increment vertex position

  // start BFS searching
  const q = new Queue();
  q.enqueue(NFA_states);
  while (q.length) {  // while still something to explore
    NFA_states = q.dequeue();
    DFA_state = combine_state_labels(NFA_states);
    for (const letter of alphabet) {  // for each letter, we add an edge
      const new_NFA_states = compute.NFA_step(NFA, NFA_states, letter);  // new states
      if (!new_NFA_states.size) {  // send to trap
        DFA[DFA_state].out.push(graph_components.make_edge(DFA_state, consts.TRAP_STATE, letter));
        trap_state_used = true;  // mark it used so we don't delete the trap state later
        continue;  // done
      }
      const new_DFA_state = combine_state_labels(new_NFA_states);
      if (!(new_DFA_state in DFA)) {  // if we don't have that state yet, create one
        DFA[new_DFA_state] = graph_components.make_vertex(new_DFA_state,
          ...vertex_position, consts.DEFAULT_VERTEX_RADIUS, false, compute.contains_final(NFA, new_NFA_states));
        vertex_position = linalg.add(3*consts.DEFAULT_VERTEX_RADIUS, vertex_position);  // increment vertex position
        q.enqueue(new_NFA_states);  // add this to be explored
      }
      DFA[DFA_state].out.push(graph_components.make_edge(DFA_state, new_DFA_state, letter));  // make edge
    }
  }
  
  // clean up
  if (!trap_state_used) {
    delete_vertex(DFA, consts.TRAP_STATE);
  }
  return DFA;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-compute.html">compute</a></li><li><a href="module-consts.html">consts</a></li><li><a href="module-drawing.html">drawing</a></li><li><a href="module-graph_components.html">graph_components</a></li><li><a href="module-graph_ops.html">graph_ops</a></li><li><a href="module-history.html">history</a></li><li><a href="module-index.html">index</a></li><li><a href="module-linalg.html">linalg</a></li><li><a href="module-menus.html">menus</a></li><li><a href="module-util.html">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Fri Mar 18 2022 00:44:35 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
